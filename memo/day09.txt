day09

	1. 메소드

		1) 메소드와 메모리 
			메소드는 실행되면 메모리의 stack영역에 메소드 실행에 필요한 저장공간이 생성된다. 
			그곳에 메소드 내부에서 선언한 변수(지역변수, 매개변수)들의 저장공간이 생성된다.
			메소드의 코드가 모두 실행되어 종료되면 stack 영역에서 메소드의 저장공간이 삭제된다 (메모리 해제)
			그러면 지역변수의 저장공간이 사라지므로 지역변수는 사용이 불가능하다.

		+ ) 스택 프레임의 장점
			메모리 관리 효율성 : 메소드 호출 할 때 필요한 메모리를 동적으로 할당하고, 호출이 끝나면 자동으로 해제한다.
			재귀적 호출 지원 : 재귀 호출에 각 호출마다 독립적인 stack frame이 생성되어, 서로 간섭없이 수행된다.
			지역성	: 스택 메모리 접근 속도가 빠르며, 지역변수와 매개 변수는 메모리 접근 비용이 적다.

		

		2) 인수와 매개변수

			인수 (Argument) : 메소드를 사용할 때 메소드의 매개변수로 전달될 값
			매개변수(parameter) : 외부에서 전달받아 값을 저장하고 메소드 내에서 사용될 변수
			메소드의 인수와 매개변수는 반드시 타입이 일치하거나 자동 형변환이 가능한 타입이어야한다.
			return되는 값은 반드시 return 타입과 일치하거나 자동 형변환이 가능한 타입이어야한다.

		3) 메소드의 사용 목적
			- 중복 코드 제거
			- 높은 재사용성
			- 유지보수에 유리함

		★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
		4) 메소드의 오버로딩(method overloading) -> 다형성 : 같은 코드로 다른 기능을 하는 것
			method : 메소드 (작업을 수행하는 코드 블록)
			overloading : 과부화 ,과적 , 프로그램에서는 같은 이름을 여러번 사용하는 것을 의미
			같은 이름의 메소드를 여러개 정의하는 것을 의미
			매개변수의 개수, 타입, 순서가 다르면 같은 이름의 메소드로 선언할 수 있다.
			반환 타입은 오버로딩에 영향을 주지 않는다.


		- 메소드 오버로딩의 조건
			리턴 타입은 같아도 상관없음
			메소드의 이름은 동일해야함
			매개변수의 타입 개수, 순서가 달라야함

		- 메소드 오버로딩의 주의사항
			매개변수의 타입, 개수, 순서가 똑같은 경우 매개변수의 이름이 다르다고 해서 오버로딩이 아니다.
			리턴 타입만 다르고 메소드의 이름과 매개변수가 동일한 경우에도 오버로딩이 아니다.


		- 메소드 오버로딩이 필요한 경우
			이름의 통일성 : 비슷한 작업을 수행하는 메소드는 같은 이름을 사용하면 직관적이다.
			코드 가독성 : 여러 작업을 하나의 이름으로 처리할 수 있어 코드가 간결해진다(메소드 이름을 따로 기억할 필요가 없다.)
		
		- 메소드 오버로딩이 가능한 이유
			컴파일러가 메소드 호출시 메소드 이름 뿐만 아니라 매개변수의 정보를 사용해서 정확히 어떤 메소드를 호출할 지 구분하기 때문
			컴파일시 메소드 이름이 다르게 지정됨
			컴파일러는 메소드의 이름과 매개변수의 정보를 합쳐서 고유한 시그니쳐(Method Signature)를 생성
			시그니쳐는 메소드 이름+ 매개변수의 타입과 개수로 구성

		- 컴파일러가 메소드를 선택하는 과정
			매개변수의 개수 확인 : 메소드 호출시 인수값의 개수와 일치하는 메소드를 먼저 찾는다.
			매개변수의 타입 확인 : 메소드 호출시 전달된 인수값의 타입과 일치하는 메소드를 찾는다.
			타입 변환 규칙 적용 : 전달된 인수값의 타입과 완전히 일치하는 메소드가 없을 경우 , 더 큰 타입으로 변환한다.
					메소드 호출(작은 타입의 값은 큰 타입으로 자동형변환 가능하기 때문)



		- 얕은 복사 -> 참조값이 복사 (원본과 복사본이 서로 의존적), 속도 빠름, 메모리 사용량은 적음
		- 깊은 복사 -> 모든 데이터 복사 (원본과 복사본이 서로 독립적) , 데이터 양에 비례 느림, 메모리 사용량은 많음, 데이터 독립성이 중요
		
		
		
	2. Call by Value 와 Call by reference
		
		1) call by value (pass by value)
			값을 복사하여 메소드에 전달하는 방식
			메소드 호출시 원본값이 복사되므로, 메소드 내부에서 값이 변경되어도 원본에는 영향을 미치지 않음.
			메소드에 인수로 전달되는 것은 변수의 값 자체
				
		
		2) call by reference(pass by reference)
			참조를 전달하여 메소드에 직접 원본 데이터를 조작할 수 있는 방식
			메소드 호출 시 데이터의 주소(참조값)가 전달되므로, 메소드 내부에서 데이터를 변경하면 원본 데이터도 변경됨.
			
			- 메소드 내부에서 참조된 객체를 수정하면, 원본 객체도 변경됨
			- C++ 등의 언어에서 지원되며, JAVA 지원되지 않음
				
		
		기본 데이터 타입			참조 타입
	전달방식 : 값 자체를 복사형 전달			참조값(주소값)을 복사하여 전달
원본 데이터 변경여부: 메소드 내부 변경이 원본에 영향없음 	참조된 객체를 변경하면 원본 객체에도 영향있음
참조값 변경여부	의미 없음				참조값 자체를 변경해도 원본 참조값에는 영향 없음. 
			  

		+ JAVA 동작
			Java는 항상 Cally by Value으로 동작한다.
		
		기본데이터 타입 : 값 자체가 복사되어 전달
		참조 타입	: 객체의 참조값(주소)이 복사되어 전달되므로 객체 내부의 데이터는 수정할 수 있지만 참조값 자체는 변경되지 않는다.
		
		* 참조타입의 동작이 call by reference 처럼 보일 수 있지만 실제로는 참조값의 복사(call by value)이다.
		
		기본 데이터 타입 : stack 메모리에 값 자체가 저장된다.
		참조 타입 : stack 메모리에 참조값이 저장되고, 객체 자체는 heap 메모리에 저장 


		3. JVM 메모리에 변수가 저장되는 위치
			기본자료형 : boolean , char, byte, short, enum, string, long, float , double
			참조 자료형 : array, enum , class, interface, 기본형을 제외한 모든 것들





